/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/*
 * Copyright [2020-2025] Renesas Electronics Corporation and/or its affiliates.  All Rights Reserved.
 * 
 * This software and documentation are supplied by Renesas Electronics Corporation and/or its affiliates and may only
 * be used with products of Renesas Electronics Corp. and its affiliates ("Renesas").  No other uses are authorized.
 * Renesas products are sold pursuant to Renesas terms and conditions of sale.  Purchasers are solely responsible for
 * the selection and use of Renesas products and Renesas assumes no liability.  No license, express or implied, to any
 * intellectual property right is granted by Renesas.  This software is protected under all applicable laws, including
 * copyright laws. Renesas reserves the right to change or discontinue this software and/or this documentation.
 * THE SOFTWARE AND DOCUMENTATION IS DELIVERED TO YOU "AS IS," AND RENESAS MAKES NO REPRESENTATIONS OR WARRANTIES, AND
 * TO THE FULLEST EXTENT PERMISSIBLE UNDER APPLICABLE LAW, DISCLAIMS ALL WARRANTIES, WHETHER EXPLICITLY OR IMPLICITLY,
 * INCLUDING WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT, WITH RESPECT TO THE
 * SOFTWARE OR DOCUMENTATION.  RENESAS SHALL HAVE NO LIABILITY ARISING OUT OF ANY SECURITY VULNERABILITY OR BREACH.
 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT WILL RENESAS BE LIABLE TO YOU IN CONNECTION WITH THE SOFTWARE OR
 * DOCUMENTATION (OR ANY PERSON OR ENTITY CLAIMING RIGHTS DERIVED FROM YOU) FOR ANY LOSS, DAMAGES, OR CLAIMS WHATSOEVER,
 * INCLUDING, WITHOUT LIMITATION, ANY DIRECT, CONSEQUENTIAL, SPECIAL, INDIRECT, PUNITIVE, OR INCIDENTAL DAMAGES; ANY
 * LOST PROFITS, OTHER ECONOMIC DAMAGE, PROPERTY DAMAGE, OR PERSONAL INJURY; AND EVEN IF RENESAS HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH LOSS, DAMAGES, CLAIMS OR COSTS.
 */

#include "common_utils.h"
#include "lcdc_ep.h"
#include "ili9881.h"
#include "stdbool.h"
#define MODULE_NAME             "LCDC"

/*******************************************************************************************************************//**
 * @addtogroup lcdc_ep
 * @{
 **********************************************************************************************************************/

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Variables to store resolution information */
uint16_t g_hz_size, g_vr_size;

/* Variables used for buffer usage */
uint32_t g_buffer_size;
uint8_t * g_p_single_buffer;
uint8_t * g_p_double_buffer;
volatile bool g_message_sent = false;
static uint8_t flag_lcdc_frameend;
void swap_buffers();
/* User defined functions */
static void screen_display(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color);
static void color_band_display(void);
/*******************************************************************************************************************//**
 * main() is generated by the RZ Configuration editor and is used to generate threads if an RTOS is used.
 * This function is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{

    fsp_err_t          err        = FSP_SUCCESS;
    fsp_pack_version_t version    = {RESET_VALUE};
    flag_lcdc_frameend = 0;

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Port initialization */
    R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);

    /* Get LCDC configuration */
    g_hz_size = (g_display_cfg.input[0].hsize);
    g_vr_size = (g_display_cfg.input[0].vsize);
    /* Initialize buffer pointers */
    g_buffer_size = (uint32_t) (g_hz_size * g_vr_size * BYTES_PER_PIXEL);
    g_p_single_buffer = (uint8_t *) g_display_cfg.input[0].p_base;
    /* Double buffer for drawing color bands with good quality */
    g_p_double_buffer = g_p_single_buffer + g_buffer_size;
    /* Initialize display buffer */
    screen_display((uint16_t)X1_CO_ORDINATE, (uint16_t)Y1_CO_ORDINATE, g_hz_size, g_vr_size, WHITE);
    /* Initialize LCDC driver */
    err = R_LCDC_Open(g_display.p_ctrl, g_display.p_cfg);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* LCDC initialization failed  */
        APP_ERR_PRINT(" ** LCDC driver initialization FAILED ** \r\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** LCDC driver initialization SUCCESSFUL ** \r\n\r\n");
    }
    /* Initialize MIPI DSI driver */
    err = R_MIPI_DSI_B_Open(&g_mipi_dsi0_ctrl, &g_mipi_dsi0_cfg);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* MIPI DSI initialization failed  */
        APP_ERR_PRINT(" ** MIPI DSI driver initialization FAILED ** \r\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** MIPI DSI driver initialization SUCCESSFUL ** \r\n\r\n");
    }


    ili9881_init(&g_mipi_dsi0_ctrl);

    /* Start MIPI DSI display output */
    R_MIPI_DSI_B_Start(g_mipi_dsi0.p_ctrl);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* MIPI DSI initialization failed  */
        APP_ERR_PRINT(" ** MIPI DSI driver start FAILED ** \r\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** MIPI DSI driver start SUCCESSFUL ** \r\n\r\n");
    }

    /* Start LCDC display output */
    err = R_LCDC_Start(g_display.p_ctrl);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* LCDC initialization failed  */
        APP_ERR_PRINT(" ** LCDC driver start FAILED ** \r\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** LCDC driver start SUCCESSFUL ** \r\n\r\n");
    }

    /* Disable layer 2 by send the NULL buffer */
    R_LCDC_BufferChange(g_display.p_ctrl, NULL, DISPLAY_FRAME_LAYER_2);

    /* Waiting interrupt generating and Clear flag */
    while(flag_lcdc_frameend == 0)
    {
        /* do nothing */
    }
    flag_lcdc_frameend = 0;

    /* Clear LCD screen using appropriate co-ordinates */
    screen_display((uint16_t)X1_CO_ORDINATE, (uint16_t)Y1_CO_ORDINATE, g_hz_size, g_vr_size, BLACK);

    /* Display color bands on LCD screen */
    color_band_display();

    while(1);
}

/*******************************************************************************************************************//**
 * @brief      Handles display buffer change event at the end of a frame.
 *
 * @param[in]  p_args    Callback arguments
 * @retval     None
 **********************************************************************************************************************/
void disp_buf_change(display_callback_args_t *p_args)
{
    if(p_args->event == DISPLAY_EVENT_FRAME_END)
    {
        flag_lcdc_frameend = 1;
    }
}

/*******************************************************************************************************************//**
 * @brief      Callback functions for MIPI DSI interrupts
 *
 * @param[in]  p_args    Callback arguments
 * @retval     None
 **********************************************************************************************************************/
void mipi_dsi_callback(mipi_dsi_callback_args_t *p_args)
{
    if(p_args->event == MIPI_DSI_EVENT_SEQUENCE_0)
    {
        g_message_sent = ((p_args->tx_status & MIPI_DSI_SEQUENCE_STATUS_DESCRIPTORS_FINISHED) == MIPI_DSI_SEQUENCE_STATUS_DESCRIPTORS_FINISHED);
    }
    else
    {
        //do nothing
    }
}

/*******************************************************************************************************************//**
 * This function displays color bands on the screen using appropriate color codes and co-ordinate values. *
 * @param[IN]  x1,y1  start point coordinates
 *             x2,y2  end point coordinates
 *             color color to display
 * @retval None
 **********************************************************************************************************************/
static void screen_display(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color)
{
    /* Declare local variables */
    uint16_t start_x, start_y, display_length, display_height;
    uint32_t start_addr;

    /* Assign co-ordinate values and calculate start address */
    start_x = x1;
    start_y = y1;
    start_addr = (uint32_t)((start_x * BYTES_PER_PIXEL) + (start_y * g_hz_size * BYTES_PER_PIXEL));

    /* Calculate display box length and height */
    display_length = (uint16_t)((x2 - x1) * BYTES_PER_PIXEL);
    display_height = (y2 - y1);

    /* Display required color band */
    for (uint16_t ver_value = X1_CO_ORDINATE; ver_value < display_height; ver_value++)
    {
        for (uint32_t hor_value = start_addr; hor_value < (start_addr + display_length); hor_value += BYTES_PER_PIXEL)
        {
            *(uint16_t *)(g_p_single_buffer + hor_value) = color;
            *(uint16_t *)(g_p_double_buffer + hor_value) = color;
        }
        start_addr = (uint32_t)(start_addr + (g_hz_size * BYTES_PER_PIXEL));
    }
}

/*******************************************************************************************************************//**
* @brief     This function display eight color band vertically on Graphical LCD.
* @param[IN]  None
* @retval     None
***********************************************************************************************************************/

static void color_band_display(void)
{
    uint16_t color[COLOR_BAND_COUNT] = {RED, GREEN, BLUE, BLACK, WHITE, YELLOW, MAGENTA, CYAN};
    uint16_t width = g_hz_size / COLOR_BAND_COUNT;

    for (uint8_t display_count = 0; display_count < COLOR_BAND_COUNT; display_count++)
    {
        screen_display((display_count * width), (uint16_t)Y1_CO_ORDINATE, (uint16_t)(((display_count * width) + width)), g_vr_size, color[display_count]);
    }
}


/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Initialize MMU. */
        R_MMU_Open (&g_mmu_ctrl, &g_mmu_cfg);
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);
    }
}
