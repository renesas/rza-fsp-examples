/***********************************************************************************************************************
 * File Name    : hal_entry.c
 * Description  : Contains data structures and functions used in hal_entry.c.
 **********************************************************************************************************************/
/***********************************************************************************************************************
 * Copyright [2022] Renesas Electronics Corporation and/or its affiliates.  All Rights Reserved.
 *
 * This software and documentation are supplied by Renesas Electronics Corporation and/or its affiliates and may only
 * be used with products of Renesas Electronics Corp. and its affiliates ("Renesas").  No other uses are authorized.
 * Renesas products are sold pursuant to Renesas terms and conditions of sale.  Purchasers are solely responsible for
 * the selection and use of Renesas products and Renesas assumes no liability.  No license, express or implied, to any
 * intellectual property right is granted by Renesas.  This software is protected under all applicable laws, including
 * copyright laws. Renesas reserves the right to change or discontinue this software and/or this documentation.
 * THE SOFTWARE AND DOCUMENTATION IS DELIVERED TO YOU "AS IS," AND RENESAS MAKES NO REPRESENTATIONS OR WARRANTIES, AND
 * TO THE FULLEST EXTENT PERMISSIBLE UNDER APPLICABLE LAW, DISCLAIMS ALL WARRANTIES, WHETHER EXPLICITLY OR IMPLICITLY,
 * INCLUDING WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NONINFRINGEMENT, WITH RESPECT TO THE
 * SOFTWARE OR DOCUMENTATION.  RENESAS SHALL HAVE NO LIABILITY ARISING OUT OF ANY SECURITY VULNERABILITY OR BREACH.
 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT WILL RENESAS BE LIABLE TO YOU IN CONNECTION WITH THE SOFTWARE OR
 * DOCUMENTATION (OR ANY PERSON OR ENTITY CLAIMING RIGHTS DERIVED FROM YOU) FOR ANY LOSS, DAMAGES, OR CLAIMS WHATSOEVER,
 * INCLUDING, WITHOUT LIMITATION, ANY DIRECT, CONSEQUENTIAL, SPECIAL, INDIRECT, PUNITIVE, OR INCIDENTAL DAMAGES; ANY
 * LOST PROFITS, OTHER ECONOMIC DAMAGE, PROPERTY DAMAGE, OR PERSONAL INJURY; AND EVEN IF RENESAS HAS BEEN ADVISED OF THE
 * POSSIBILITY OF SUCH LOSS, DAMAGES, CLAIMS OR COSTS.
 **********************************************************************************************************************/

#include "common_utils.h"
#include "lcdc_ep.h"
#include "adv7513.h"
#include "stdbool.h"

/*******************************************************************************************************************//**
 * @addtogroup lcdc_ep
 * @{
 **********************************************************************************************************************/

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/* Variables to store resolution information */
uint16_t g_hz_size, g_vr_size;

/* Variables used for buffer usage */
uint32_t g_buffer_size;
uint8_t * g_p_single_buffer;
uint8_t * g_p_double_buffer;

static uint8_t flag_lcdc_frameend;

/* User defined functions */
static void screen_display(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color);
static void color_band_display(void);

/*******************************************************************************************************************//**
 * main() is generated by the RZA3UL Configuration editor and is used to generate threads if an RTOS is used.
 * This function is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{

    fsp_err_t          err        = FSP_SUCCESS;
    fsp_pack_version_t version    = {RESET_VALUE};
    flag_lcdc_frameend = 0;

    /* version get API for FLEX pack information */
    R_FSP_VersionGet(&version);

    /* Project information printed on the Console */
    APP_PRINT(BANNER_INFO, EP_VERSION, version.version_id_b.major, version.version_id_b.minor, version.version_id_b.patch);
    APP_PRINT(EP_INFO);

    /* Port initialization */
    R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);

    /* Initialize adv7513 for display  */
    adv7513_init();

    /* 32,26MHz 800x480 */
    uint32_t reg;
    uint32_t fracin;
    uint32_t intin;
    uint32_t refdiv;
    uint32_t postdiv1;
    uint32_t postdiv2;
    uint32_t divdsia_set;
    uint32_t divdsib_set;

    fracin   = 894785;
    intin    = 172;
    refdiv    = 2;
    postdiv1 = 4;
    postdiv2 = 4;
    divdsia_set = 2;
    divdsib_set = 0;

    /* Setting for PIXEL Clock (PLL5 Pixel Clock) */
    reg  = R_CPG->CPG_SIPLL5_CLK3;
    reg &= 0x0000FFFF;
    reg |= (fracin << 8);
    R_CPG->CPG_SIPLL5_CLK3 = reg;
    R_CPG->CPG_SIPLL5_CLK4 = (intin << 16);
    reg = R_CPG->CPG_SIPLL5_CLK1;
    reg &= 0xFFFF0000;
    reg |= ( (1 << 24) | (1 << 20) | (1 << 16) | (refdiv << 8) | (postdiv2 << 4) | postdiv1 );
    R_CPG->CPG_SIPLL5_CLK1 = reg;
    reg = 0x01010000;
    reg |= (divdsib_set << 8) | (divdsia_set);
    R_CPG->CPG_PL5_SDIV  = reg;
    R_CPG->CPG_SIPLL5_STBY = 0x00150001;

    /* Get LCDC configuration */
    g_hz_size = (g_display_cfg.input[0].hsize);
    g_vr_size = (g_display_cfg.input[0].vsize);
    /* Initialize buffer pointers */
    g_buffer_size = (uint32_t) (g_hz_size * g_vr_size * BYTES_PER_PIXEL);
    g_p_single_buffer = (uint8_t *) g_display_cfg.input[0].p_base;
    /* Double buffer for drawing color bands with good quality */
    g_p_double_buffer = g_p_single_buffer + g_buffer_size;
    /* Initialize display buffer */
    screen_display((uint16_t)X1_CO_ORDINATE, (uint16_t)Y1_CO_ORDINATE, g_hz_size, g_vr_size, WHITE);

    /* Initialize LCDC driver */
    err = R_LCDC_Open(g_display.p_ctrl, g_display.p_cfg);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* LCDC initialization failed  */
        APP_ERR_PRINT(" ** LCDC driver initialization FAILED ** \r\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** LCDC driver initialization SUCCESSFUL ** \r\n\r\n");
    }

    /* Start LCDC display output */
    err = R_LCDC_Start(g_display.p_ctrl);
    /* Handle error */
    if(FSP_SUCCESS != err)
    {
        /* LCDC initialization failed  */
        APP_ERR_PRINT(" ** LCDC driver start FAILED ** \r\n\n\r\n");
        APP_ERR_TRAP(err);
    }
    else
    {
        APP_PRINT(" ** LCDC driver start SUCCESSFUL ** \r\n\n\r\n");
    }

    /* Disable layer 2 by send the NULL buffer */
    R_LCDC_BufferChange(g_display.p_ctrl, NULL, DISPLAY_FRAME_LAYER_2);

    /* Waiting interrupt generating and Clear flag */
    while(flag_lcdc_frameend == 0)
    {
        /* do nothing */
    }
    flag_lcdc_frameend = 0;

    /* Clear LCD screen using appropriate co-ordinates */
    screen_display((uint16_t)X1_CO_ORDINATE, (uint16_t)Y1_CO_ORDINATE, g_hz_size, g_vr_size, BLACK);

    /* Display color bands on LCD screen */
    color_band_display();

    while(1);
}

void disp_buf_change(display_callback_args_t *p_args)
{
    if(p_args->event == DISPLAY_EVENT_FRAME_END)
    {
        flag_lcdc_frameend = 1;
    }
}

/*******************************************************************************************************************//**
 * This function displays color bands on the screen using appropriate color codes and co-ordinate values. *
 * @param[IN]  x1,y1  start point coordinates
 *             x2,y2  end point coordinates
 *             color color to display
 * @retval None
 **********************************************************************************************************************/
static void screen_display(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t color)
{
    /*Declare local variables */
    uint16_t start_x, start_y, display_length, display_height;
    uint32_t start_addr;

    /* Assign co-ordinate values and calculate start address */
    start_x = x1;
    start_y = y1;
    start_addr = (uint32_t)((start_x * BYTES_PER_PIXEL) + (start_y * g_hz_size* BYTES_PER_PIXEL));

    /* Calculate display box length and height */
    display_length = (uint16_t)((x2 - x1) * BYTES_PER_PIXEL);
    display_height = (y2 - y1);

    /* Display required color band */
    for(uint16_t ver_value = Y1_CO_ORDINATE; ver_value < (display_height - INC_DEC_VALUE); ver_value ++)
    {
        for(uint32_t hor_value = start_addr; hor_value < (start_addr + display_length); hor_value += BYTES_PER_PIXEL)
        {
            *(uint16_t *) (g_p_single_buffer + hor_value) = color;
            *(uint16_t *) (g_p_double_buffer + hor_value) = color;
        }
        start_addr = (uint32_t)(start_addr + (g_hz_size * BYTES_PER_PIXEL));
    }
}

/*******************************************************************************************************************//**
 * @brief     This function display eight color band horizontally on Graphical LCD .
 * @param[IN]  None
 * @retval     None
 ***********************************************************************************************************************/
static void color_band_display(void)
{
    uint16_t color[COLOR_BAND_COUNT]= {RED, GREEN, BLUE, BLACK, WHITE, YELLOW, MAGENTA, CYAN};
    uint16_t width = g_vr_size/COLOR_BAND_COUNT;

    for (uint8_t display_count = RESET_VALUE; display_count < COLOR_BAND_COUNT; display_count++)
    {
        screen_display((uint16_t)X1_CO_ORDINATE, (display_count * width), g_hz_size, (uint16_t)(((display_count * width) + width) + INC_DEC_VALUE), color[display_count]);
    }
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
        /* Initialize MMU. */
        R_MMU_Open(&g_mmu_ctrl, &g_mmu_cfg);
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        IOPORT_CFG_OPEN(&IOPORT_CFG_CTRL, &IOPORT_CFG_NAME);
    }
}
